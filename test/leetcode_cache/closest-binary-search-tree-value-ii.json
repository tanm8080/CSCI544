{
  "questionId": "272",
  "questionFrontendId": "272",
  "title": "Closest Binary Search Tree Value II",
  "content": null,
  "difficulty": "Hard",
  "exampleTestcases": "[4,2,5,1,3]\n3.714286\n2\n[1]\n0.000000\n1",
  "exampleTestcaseList": [
    "[4,2,5,1,3]\n3.714286\n2",
    "[1]\n0.000000\n1"
  ],
  "sampleTestCase": "[4,2,5,1,3]\n3.714286\n2",
  "metaData": "{\r\n  \"name\": \"closestKValues\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    },\r\n    {\r\n      \"name\": \"target\",\r\n      \"type\": \"double\"\r\n    },\r\n    {\r\n      \"name\": \"k\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"list<integer>\"\r\n  }\r\n}",
  "codeSnippets": null,
  "hints": [
    "Consider implement these two helper functions:\r\n<ol type=\"i\"><li><code>getPredecessor(N)</code>, which returns the next smaller node to N.</li>\r\n<li><code>getSuccessor(N)</code>, which returns the next larger node to N.</li>\r\n</ol>",
    "Try to assume that each node has a parent pointer, it makes the problem much easier.",
    "Without parent pointer we just need to keep track of the path from the root to the current node using a stack.",
    "You would need two stacks to track the path in finding predecessor and successor node separately."
  ]
}