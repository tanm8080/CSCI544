{
  "questionId": "282",
  "questionFrontendId": "282",
  "title": "Expression Add Operators",
  "content": "<p>Given a string <code>num</code> that contains only digits and an integer <code>target</code>, return <em><strong>all possibilities</strong> to insert the binary operators </em><code>&#39;+&#39;</code><em>, </em><code>&#39;-&#39;</code><em>, and/or </em><code>&#39;*&#39;</code><em> between the digits of </em><code>num</code><em> so that the resultant expression evaluates to the </em><code>target</code><em> value</em>.</p>\n\n<p>Note that operands in the returned expressions <strong>should not</strong> contain leading zeros.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;123&quot;, target = 6\n<strong>Output:</strong> [&quot;1*2*3&quot;,&quot;1+2+3&quot;]\n<strong>Explanation:</strong> Both &quot;1*2*3&quot; and &quot;1+2+3&quot; evaluate to 6.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;232&quot;, target = 8\n<strong>Output:</strong> [&quot;2*3+2&quot;,&quot;2+3*2&quot;]\n<strong>Explanation:</strong> Both &quot;2*3+2&quot; and &quot;2+3*2&quot; evaluate to 8.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;3456237490&quot;, target = 9191\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no expressions that can be created from &quot;3456237490&quot; to evaluate to 9191.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10</code></li>\n\t<li><code>num</code> consists of only digits.</li>\n\t<li><code>-2<sup>31</sup> &lt;= target &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
  "difficulty": "Hard",
  "exampleTestcases": "\"123\"\n6\n\"232\"\n8\n\"3456237490\"\n9191",
  "exampleTestcaseList": [
    "\"123\"\n6",
    "\"232\"\n8",
    "\"3456237490\"\n9191"
  ],
  "sampleTestCase": "\"123\"\n6",
  "metaData": "{\r\n    \"name\":\"addOperators\",\r\n    \"params\":[\r\n        {\r\n            \"name\":\"num\",\r\n            \"type\":\"string\"\r\n        },\r\n        {\r\n            \"name\":\"target\",\r\n            \"type\":\"integer\"\r\n        }\r\n    ],\r\n    \"return\":{\r\n        \"type\":\"list<string>\"\r\n    }\r\n}",
  "codeSnippets": [
    {
      "lang": "C++",
      "langSlug": "cpp",
      "code": "class Solution {\npublic:\n    vector<string> addOperators(string num, int target) {\n        \n    }\n};"
    },
    {
      "lang": "Java",
      "langSlug": "java",
      "code": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        \n    }\n}"
    },
    {
      "lang": "Python",
      "langSlug": "python",
      "code": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        "
    },
    {
      "lang": "Python3",
      "langSlug": "python3",
      "code": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        "
    },
    {
      "lang": "C",
      "langSlug": "c",
      "code": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** addOperators(char* num, int target, int* returnSize) {\n    \n}"
    },
    {
      "lang": "C#",
      "langSlug": "csharp",
      "code": "public class Solution {\n    public IList<string> AddOperators(string num, int target) {\n        \n    }\n}"
    },
    {
      "lang": "JavaScript",
      "langSlug": "javascript",
      "code": "/**\n * @param {string} num\n * @param {number} target\n * @return {string[]}\n */\nvar addOperators = function(num, target) {\n    \n};"
    },
    {
      "lang": "TypeScript",
      "langSlug": "typescript",
      "code": "function addOperators(num: string, target: number): string[] {\n    \n};"
    },
    {
      "lang": "PHP",
      "langSlug": "php",
      "code": "class Solution {\n\n    /**\n     * @param String $num\n     * @param Integer $target\n     * @return String[]\n     */\n    function addOperators($num, $target) {\n        \n    }\n}"
    },
    {
      "lang": "Swift",
      "langSlug": "swift",
      "code": "class Solution {\n    func addOperators(_ num: String, _ target: Int) -> [String] {\n        \n    }\n}"
    },
    {
      "lang": "Kotlin",
      "langSlug": "kotlin",
      "code": "class Solution {\n    fun addOperators(num: String, target: Int): List<String> {\n        \n    }\n}"
    },
    {
      "lang": "Dart",
      "langSlug": "dart",
      "code": "class Solution {\n  List<String> addOperators(String num, int target) {\n    \n  }\n}"
    },
    {
      "lang": "Go",
      "langSlug": "golang",
      "code": "func addOperators(num string, target int) []string {\n    \n}"
    },
    {
      "lang": "Ruby",
      "langSlug": "ruby",
      "code": "# @param {String} num\n# @param {Integer} target\n# @return {String[]}\ndef add_operators(num, target)\n    \nend"
    },
    {
      "lang": "Scala",
      "langSlug": "scala",
      "code": "object Solution {\n    def addOperators(num: String, target: Int): List[String] = {\n        \n    }\n}"
    },
    {
      "lang": "Rust",
      "langSlug": "rust",
      "code": "impl Solution {\n    pub fn add_operators(num: String, target: i32) -> Vec<String> {\n        \n    }\n}"
    },
    {
      "lang": "Racket",
      "langSlug": "racket",
      "code": "(define/contract (add-operators num target)\n  (-> string? exact-integer? (listof string?))\n  )"
    },
    {
      "lang": "Erlang",
      "langSlug": "erlang",
      "code": "-spec add_operators(Num :: unicode:unicode_binary(), Target :: integer()) -> [unicode:unicode_binary()].\nadd_operators(Num, Target) ->\n  ."
    },
    {
      "lang": "Elixir",
      "langSlug": "elixir",
      "code": "defmodule Solution do\n  @spec add_operators(num :: String.t, target :: integer) :: [String.t]\n  def add_operators(num, target) do\n    \n  end\nend"
    }
  ],
  "hints": [
    "Note that a number can contain multiple digits.",
    "Since the question asks us to find <b>all</b> of the valid expressions, we need a way to iterate over all of them. (<b>Hint:</b> Recursion!)",
    "We can keep track of the expression string and evaluate it at the very end. But that would take a lot of time. Can we keep track of the expression's value as well so as to avoid the evaluation at the very end of recursion?",
    "Think carefully about the multiply operator. It has a higher precedence than the addition and subtraction operators. \r\n\r\n<br> 1 + 2 = 3  <br>\r\n1 + 2 - 4 --> 3 - 4 --> -1 <br>\r\n1 + 2 - 4 * 12 --> -1 * 12 --> -12 (WRONG!) <br>\r\n1 + 2 - 4 * 12 --> -1 - (-4) + (-4 * 12) --> 3 + (-48) --> -45 (CORRECT!)",
    "We simply need to keep track of the last operand in our expression and reverse it's effect on the expression's value while considering the multiply operator."
  ]
}